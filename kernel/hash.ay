use("core")
use("define")
use("control-flow")

hash-key-from(x) := x
hash-key-from(x: Atomy::AST::Word) := `#~x
hash-key-from(x: Atomy::AST::Compose) :=
  if(x right is-a?(Atomy::AST::Block))
    then: x
    else: hash-key-from(x right)

hash-pair-from(x) :=
  raise("unknown pair `" + x inspect + "'")

hash-pair-from(`(~k -> ~v)) :=
  [[k, v]]

hash-pair-from(p: `(~x { ~*ys })) := do:
  this = [[hash-key-from(x), `(do: ~*ys)]]

  if(x is-a?(Atomy::AST::Compose) && !(x right is-a?(Atomy::AST::Block)))
    then: hash-pair-from(x left) + this
    else: this

hash-pairs-from(es) :=
  hash-pair-from(e) for(e) in(es) flatten(1)


class(Atomy::AST::Hash < Atomy::AST::Node):
  children([#keys], [#values])
  generate

  bytecode(g) := do:
    pos(g)

    g push-cpath-top
    g find-const(#Hash)
    g push-int(@keys size)
    g send(#new-from-literal, 1)

    @keys each-with-index [n, i]:
      g dup
      n compile(g)
      @values [i] compile(g)
      g send("[]=" to-sym, 2)
      g pop


macro(#~(l: List)):
  pairs = hash-pairs-from(l elements)
  keys = pairs collect [[k, _]]: k
  values = pairs collect [[_, v]]: v
  Atomy::AST::Hash new(line, keys, values)

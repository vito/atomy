for-macro:
  namespaced(n) :=
    Atomy namespaced(n namespace, n name)

macro(namespace(n: Variable)):
  `(evaluate-when(compile, run, load):
      Atomy::Namespace ensure(#~namespaced(n)))

macro(let-when(when-list, *bindings) ~(b: Block)):
  tmps = names(bindings size)
  save = []
  set = []
  restore = []

  when =
    when-list match:
      `[~*xs] -> xs
      x -> [x]

  bindings zip(tmps) [[`(~n = ~v), tmp]]:
    save << `(Atomy::STATE [#~tmp] = ^~n)
    set << set-dynvar(n, v)
    restore << set-dynvar(n, `(Atomy::STATE delete(#~tmp)))

  names [res]:
    `(let(~*bindings):
        evaluate-when(~*when):
          ~*save
          ~*set

        ~res = ~(b body)

        evaluate-when(~*when):
          ~restore

        ~res)

macro(in-namespace(n) ~(b: Block)):
  `(do:
      evaluate-when(load, run):
        Atomy::Namespace create(#~namespaced(n))

      let-when(compile, namespace = Atomy::Namespace ensure(#~namespaced(n))):
        ~(b body))

macro('no-namespace ~(b: Block)):
  `(let-when(compile, namespace = nil):
      ~(b body))

macro('export ~(b: Block)):
  `(let-when([compile, load, run], define-in = "_"):
      ~(b body))

macro(export-to(n) ~(b: Block)):
  `(let-when([compile, load, run], define-in = ~namespaced(n)):
      ~(b body))

macro(use(*ns)):
  current = Atomy::Namespace get
  where = current && current name

  `(evaluate-when(compile, run, load):
      ~*(ns collect [n]:
          `(Atomy::Namespace get(~where) use(#~namespaced(n)))))

macro(symbols(*ns)):
  current = Atomy::Namespace get
  where = current && current name

  `(evaluate-when(compile, run, load):
      ~*(ns collect [n]:
          `(Atomy::Namespace register(#~n, ~where))))

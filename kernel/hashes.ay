namespace(atomy)

for-macro:
  key-name(x: Atomy::AST::Compose) := key-name(x message)
  key-name(x: Atomy::AST::Variable) := x name

macro(#(l: List)):
  keys = []
  values = []

  pairs = l elements dup
  until(pairs empty?):
    pairs pop match:
      `(~k -> ~v) -> do:
        keys << k
        values << v

      (p: Compose) -> do:
        while(p is-a?(Compose) && p message is-a?(Block)):
          keys << `#~(key-name(p receiver))
          values << p message contents first
          pairs += p message contents [1 .. -1]
          if(p receiver is-a?(Compose))
            then: p =! p receiver receiver
            else: break

  Atomy::AST::Hash new(line, keys, values)

export:
  class(Atomy::AST::Hash < Atomy::AST::Node):
    children([#keys], [#values])
    generate

    bytecode(g) := do:
      pos(g)

      g push-cpath-top
      g find-const(#Hash)
      g push-int(@keys size)
      g send(#new-from-literal, 1)

      @keys each-with-index [n, i]:
        g dup
        n compile(g)
        @values [i] compile(g)
        g send("[]=" to-sym, 2)
        g pop

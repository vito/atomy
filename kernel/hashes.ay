for-macro:
  key-name(x: Atomy::AST::Compose) := key-name(x message)
  key-name(x: Atomy::AST::Variable) := x name

macro(#(l: List)):
  keys = []
  values = []

  pairs = l elements dup
  until(pairs empty?):
    pairs pop match:
      `(~k -> ~v) -> do:
        keys << k
        values << v

      (p: Compose) -> do:
        while(p is-a?(Compose) && p message is-a?(Block)):
          keys << `#~(key-name(p receiver))
          values << p message contents first
          pairs += p message contents [1 .. -1]
          if(p receiver is-a?(Compose))
            then: p =! p receiver receiver
            else: break

  Atomy::AST::Hash new(line, keys, values)

class(Atomy::AST::Hash < Atomy::AST::Node):
  children([#keys], [#values])
  generate

  bytecode(g) := do:
    pos(g)

    g push-cpath-top
    g find-const(#Hash)
    g push-int(@keys size)
    g send(#new-from-literal, 1)

    @keys each-with-index [n, i]:
      g dup
      n compile(g)
      @values [i] compile(g)
      g send("[]=" to-sym, 2)
      g pop

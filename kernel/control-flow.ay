use("core")
use("define")
use("comparison")

macro(if(~x) then ~(y: Block) else ~(z: Block)):
  IfThenElse new(node line, x, y body, z body)

macro(otherwise): 'true

macro(return(~y)):
  Return new(node line, y)

macro(~x ensuring ~(y: Block)):
  Ensure new(node line, x caller, y body)

macro(when(~c) ~(b: Block)):
  When new(node line, c, b body)

macro(unless(~c) ~(b: Block)):
  When new(node line, `!~c, b body)

macro(super):
  ZSuper new(node line)

splat-from(arguments) := do:
  args = arguments dup

  splat =
    if(args last is-a?(Atomy::AST::Prefix) && args last receiver == "*" to-sym)
      then: args pop receiver
      else: nil

  [args, splat]

macro(super &~blk):
  Super new(node line, [], nil, blk)

macro(super ~(blk: Block)):
  Super new(node line, [], nil, blk)

macro(super(~*as)):
  [args, splat] = splat-from(as)
  Super new(node line, args, splat)

macro(super(~*as) ~(blk: Block)):
  [args, splat] = splat-from(as)
  Super new(node line, args, splat, blk)

macro(super(~*as) &~blk):
  [args, splat] = splat-from(as)
  Super new(node line, args, splat, blk)


module(Atomy::AST):
  class(Break < Node):
    children(#value)
    generate

    bytecode(g) := do:
      pos(g)
      @value compile(g)
      g raise-break

  class(Next < Node):
    children(#value)
    generate

    bytecode(g) := do:
      pos(g)
      @value compile(g)
      g ret


macro(break):
  Break new(node line, 'nil)

macro(break(~x)):
  Break new(node line, x)

macro(next):
  Next new(node line, 'nil)

macro(next(~x)):
  Next new(node line, x)

key-from(x) := x
key-from(x: Atomy::AST::Compose) :=
  if(x right is-a?(Atomy::AST::Block))
    then: x
    else: x right

pair-from(x) :=
  raise("unknown pair `" + x inspect + "'")

pair-from(`(~k -> ~v)) :=
  [[k, v]]

pair-from(p: `(~x { ~*ys })) := do:
  this = [[key-from(x), `(do: ~*ys)]]

  if(x is-a?(Atomy::AST::Compose) && !(x right is-a?(Atomy::AST::Block)))
    then: pair-from(x left) + this
    else: this

pairs-from(es) :=
  es collect [e] { pair-from(e) } flatten(1)

macro(condition ~(b: Block)):
  pairs-from(b contents) reverse inject('nil) [acc, [x, y]]:
    `(if(~x) then: ~y; else: ~acc)

macro(~val match ~(b: Block)):
  branches = pairs-from(b contents) collect [[x, y]]:
    MatchBranch new(x line, x to-pattern to-node, y)

  Match new(node line, val, branches)

macro(~x rescue ~(y: Block)):
  branches = pairs-from(y contents) collect [[p, e]]:
    RescueHandler new(p line, p, e)

  Catch new(node line, x caller, branches)

macro(~x rescue ~(y: Block) else ~(z: Block)):
  branches = pairs-from(y contents) collect [[p, e]]:
    RescueHandler new(p line, p, e)

  Catch new(node line, x caller, branches, z body)

module(Atomy::AST):
  class(Super < Node):
    children([#arguments], #splat?, #block?)
    generate

    bytecode(g) := do:
      pos(g)

      @arguments each [a]:
        a compile(g)

      when(@splat):
        @splat compile(g)
        g cast-array

      if(@block)
        then: @block compile(g)
        else: g push-nil

      g send-super(nil, @arguments size, !!@splat)

  class(ZSuper < Node):
    generate

    bytecode(g) := do:
      pos(g)

      g push-block

      if(g state super?)
        then:
          g zsuper(g state super name)
        else:
          g zsuper(nil)

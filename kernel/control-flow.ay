dynamic(labels, Hash new)

macro(if(x) then ~(y: Block) else ~(z: Block)):
  IfThenElse new(line, x, y body, z body)

macro(otherwise): 'true

macro('condition ~(bs: Block)):
  bs contents reverse inject('nil) [acc, `(~x -> ~y)]:
    `(if(~x) then: ~y; else: ~acc)

macro(return(y)):
  Return new(line, y)

macro(x rescue ~(y: Block)):
  branches = y contents collect [`(~p -> ~e)]:
    RescueHandler new(p line, p, e)

  Catch new(line, x caller, branches)

macro(x rescue ~(y: Block) else ~(z: Block)):
  branches = y contents collect [`(~p -> ~e)]:
    RescueHandler new(p line, p, e)

  Catch new(line, x caller, branches, z body)

macro(x ensuring ~(y: Block)):
  Ensure new(line, x caller, y body)

macro(when(c) ~(b: Block)):
  When new(line, c, b body)

macro(unless(c) ~(b: Block)):
  When new(line, `!~c, b body)

macro(super):
  ZSuper new(line)

macro('super ~(blk: Block)):
  Super new(line, [], blk)

macro(super(*args) ~(blk: Block)):
  Super new(line, args, blk)

macro(super(*args)):
  Super new(line, args, nil)

macro(yield):
  Yield new(line, [])

macro(yield(*args)):
  Yield new(line, args)

macro(break):
  Break new(line, 'nil)

macro(break(x)):
  Break new(line, x)

macro(next):
  Next new(line, 'nil)

macro(next(x)):
  Next new(line, x)

module(Atomy::AST):
  class(Labels < Node):
    children([#tags])
    generate

    bytecode(g) := do:
      pos(g)

      tags = ::Hash new

      labels =
        @tags collect [t]:
          tags [t name] = g new-label

      let(labels = tags):
        labels zip(@tags) each [[l, t]]:
          l set!
          t body compile(g)
          g pop

      g push-nil

  class(LabelBranch < Node):
    children(#body)
    attributes(#name)
    generate

  class(GoTo < Node):
    attributes(#name)
    generate

    bytecode(g) := do:
      pos(g)
      g goto(^labels fetch(@name))

  class(ZSuper < Node):
    generate

    bytecode(g) := do:
      pos(g)

      g push-block

      if(g state super?)
        then:
          g zsuper(g state super name)
        else:
          g zsuper(nil)

  class(Super < Node):
    children([#arguments], #block?)
    generate

    bytecode(g) := do:
      pos(g)

      block = @block
      splat = nil

      args = 0
      @arguments each [a]:
        e = a prepare
        e match:
          BlockPass -> do:
            block =! e
            -- break

          Splat -> do:
            splat =! e
            -- break

          _ -> do:
            e bytecode(g)
            args += 1

      when(splat):
        splat compile(g)
        g cast-array

      if(block)
        then: block compile(g)
        else: g push-nil

      g send-super(nil, args, splat)

  class(Yield < Node):
    children([#arguments])
    generate

    bytecode(g) := do:
      pos(g)

      splat = nil

      args = 0
      @arguments each [a]:
        e = a prepare
        e match:
          Splat -> do:
            splat =! e
            -- break

          _ -> do:
            e bytecode(g)
            args += 1

      if(splat)
        then:
          splat compile(g)
          g cast-array
          g yield-splat(args)
        else:
          g yield-stack(args)

  class(Break < Node):
    children(#value)
    generate

    bytecode(g) := do:
      pos(g)
      @value compile(g)
      g raise-break

  class(Next < Node):
    children(#value)
    generate

    bytecode(g) := do:
      pos(g)
      @value compile(g)
      g ret

macro('labels ~(body: Block)):
  branches = body contents collect [`(~(n) ~(b))]:
    LabelBranch new(n line, b body, n name)

  `(let-macro(go(name) = GoTo new(line, name name)):
      ~(Labels new(line, branches)))

macro(while(test) ~(body: Block)):
  names [loop, done]:
    `(labels:
        ~loop:
          unless(~test):
            go(~done)

          let-macro(break = 'go(~done),
                    next = 'go(~loop)):
            ~(body caller)

          go(~loop)

        ~done {})

macro(until(test) ~(body: Block)):
  names [loop, done]:
    `(labels:
        ~loop:
          when(~test):
            go(~done)

          let-macro(break = 'go(~done),
                    next = 'go(~loop)):
            ~(body caller)

          go(~loop)

        ~done {})

macro('loop ~(body: Block)):
  names [loop, done]:
    `(labels:
        ~loop:
          let-macro(break = 'go(~done),
                    next = 'go(~loop)):
            ~(body caller)

          go(~loop)

        ~done {})

module(Atomy::Patterns):
  -- pattern precision hierarchy, from least precise to most
  [ [ Any, BlockPass, Splat, Attribute,
      NamedClass, NamedGlobal, NamedInstance
    ]

    [Constant, SingletonClass, RuntimeClass]

    [HeadTail]

    [List, QuasiQuote]

    [Match, Literal, Quote]
  ] each-with-index [ps, i]:
      ps each [a]:
        a send(#define-method, #precision):
          i

  Pattern precision := 0

  Named precision := @pattern precision

  Predicate precision :=
    @pattern precision + 1

  (a: Pattern) <=> (b: Pattern) :=
    a precision <=> b precision

  (a: BlockPass) <=> (b: BlockPass) :=
    a pattern <=> b pattern

  (a: Constant) <=> (b: Constant) :=
    condition:
      !(a value is-a?(Class) && b value is-a?(Class)) ->
        0

      (a value ancestors nil? || b value ancestors nil?) ->
        0

      (a value ancestors first == b value ancestors first) ->
        0

      b value ancestors include?(a value ancestors first) ->
        -1

      a value ancestors include?(b value ancestors first) ->
        1

      otherwise ->
        0

  (a: HeadTail) <=> (b: HeadTail) :=
    Atomy::Patterns
      compare([a head, a tail], [b head, b tail])

  (a: List) <=> (b: List) :=
    Atomy::Patterns
      compare(a patterns, b patterns)

  (a: Splat) <=> (b: Splat) :=
    a pattern <=> b pattern

  (a: Default) <=> (b: Default) :=
    a pattern <=> b pattern
  (d: Default) <=> (p: Pattern) := d pattern <=> p
  (p: Pattern) <=> (d: Default) := p <=> d pattern

  (a: Named) <=> (b: Named) :=
    a pattern <=> b pattern
  (n: Named) <=> (p: Pattern) :=
    n pattern <=> p
  (p: Pattern) <=> (n: Named) :=
    p <=> n pattern

  (a: QuasiQuote) <=> (b: QuasiQuote) := do:
    total = 0

    a quoted walk-with(
      b quoted
      [a, b] { a unquote? && b unquote? }
    ) [x, y]:
      condition:
        x nil? || y nil? ->
          -- consider splice unquotes to be the same precision as if they
          -- were not there
          unless(x is-a?(Atomy::AST::Splice) || y is-a?(Atomy::AST::Splice)):
            if(x nil?)
              then: total -= 1
              else: total += 1

        x unquote? && y unquote? ->
          (total +=
            (x expression to-pattern <=>
              y expression to-pattern))

        x unquote? ->
          (total +=
            (x expression to-pattern <=>
              `'~y to-pattern))

        y unquote? ->
          (total +=
            (`'~x to-pattern <=>
              y expression to-pattern))

    total <=> 0


  -- equivalence ignores named patterns
  (a: Named) =~ (b: Named) :=
    a pattern =~ b pattern
  Named =~ (p: Pattern) := pattern =~ p
  Pattern =~ (n: Named) := (=~ n pattern)

  Any =~ Any := true

  (a: BlockPass) =~ (b: BlockPass) :=
    a pattern =~ b pattern

  (a: Constant) =~ (b: Constant) :=
    a constant =~ b constant

  (a: Default) =~ (b: Default) :=
    a pattern =~ b pattern
  Default =~ (p: Pattern) := pattern =~ p
  Pattern =~ (n: Default) := (=~ n pattern)

  (a: HeadTail) =~ (b: HeadTail) :=
    a head =~ b head && a tail =~ b tail

  (a: List) =~ (b: List) :=
    a patterns size == b patterns size &&
      a patterns zip(b patterns) all? [[a, b]]:
        a =~ b

  (a: Match) =~ (b: Match) :=
    a value == b value

  (a: Literal) =~ (b: Literal) :=
    a value == b value

  (a: SingletonClass) =~ (b: SingletonClass) :=
    a body == b body

  NamedClass =~ NamedClass := true

  NamedGlobal =~ NamedGlobal := true

  NamedInstance =~ NamedInstance := true

  (a: QuasiQuote) =~ (b: QuasiQuote) :=
    -- TODO: go through quotes.
    a expression == b expression

  (a: Quote) =~ (b: Quote) :=
    a expression == b expression

  (a: Splat) =~ (b: Splat) :=
    a pattern =~ b pattern

  (a: Attribute) =~ (b: Attribute) :=
    a receiver == b receiver &&
      a name == b name &&
      a arguments == b arguments

  Pattern =~ Pattern := false


  -- helper for comparing aggregate patterns like lists
  { self } compare(xs, ys) := do:
    total = 0

    xs zip(ys) [[x, y]]:
      unless(y nil?):
        total += x <=> y

    total <=> 0

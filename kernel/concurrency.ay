namespace(atomy)

require("actor")

title"Concurrency"

doc"
  Get the current actor.
" spec {
  => Actor
} for:
  me := Actor current


section("Sending & Receiving"):
  doc"
    Send message \code{v} to the actor.
  " spec {
    => Actor
  } for {
    Actor <- v := send(v)
  } examples:
    a = spawn: receive { 42 -> #ok } write
    a <- 42

  doc"
    Receive a message sent to the current actor that matches any of the \
    patterns listed in \hl{body}. Blocks until a matching message is \
    received. Non-matching messages are consumed and ignored.
  " spec {
    body contents all? [x]: x match { `(~_ -> ~_) -> true, _ -> false }
    => any
  } for {
    macro(receive(&body)):
      names [e]:
        bs = body contents collect [`(~pat -> ~exp)]:
          `(~e when('~pat to-pattern) [~pat]: ~exp)

        `(Actor receive [~e]: ~*bs)
  } examples:
    a = spawn: receive { 1 -> #got-1 } write
    a <- 0
    a <- 2
    a <- 1

  doc"
    Similar to \code{receive}, but with a timeout and an action to \
    perform if it times out.
  " spec {
    body contents all? [x]: x match { `(~_ -> ~_) -> true, _ -> false }
    timeout match: `(~_ -> ~_) -> true, _ -> false
    => any
  } for {
    macro(receive(&body) after(timeout)):
      names [e]:
        bs = body contents collect [`(~pat -> ~exp)]:
          `(~e when('~pat to-pattern) [~pat]: ~exp)

        bs << `(~e after(~(timeout lhs)): ~(timeout rhs))

        `(Actor receive [~e]: ~*bs)
  } examples:
    receive { 1 -> #ok } after(1 -> #too-slow)


section("Spawning"):
  doc"
    Spawn a new actor, performing \code{action}.
  " spec {
    => Actor
  } for {
    spawn(&action) := Actor send(#spawn, &action)
  } examples:
    spawn: (2 + 2) write

  doc"
    Spawn a new actor, performing \code{action}, linked to the current \
    actor.
  " spec {
    => Actor
  } for {
    spawn-link(&action) := Actor send(#spawn-link, &action)
  } examples:
    spawn-link: (2 + 2) write

use("core")
use("define")
use("data")
use("control-flow")
use("cosmetics")
use("undefined")

Atomy = ::Atomy

module(Atomy):
  data(Particle(@receiver, @message, @arguments))

  Particle call(*args) := to-proc [*args]

  Particle to-proc := [*args]:
    [recv, cur] =
      if(@receiver equal?(_undefined))
        then: [args[0], 1]
        else: [@receiver, 0]

    filled =
      @arguments collect [v]:
        if(v equal?(_undefined))
          then:
            cur += 1
            args[cur - 1]
          else:
            v

    recv send(@message, *filled)

  Particle arity :=
    (@receiver . @arguments) select #equal?(_undefined) size

Symbol call(*args) := to-proc [*args]

Symbol arity := 1

wildcard('_) := '_undefined
wildcard(x) := x

macro(#(~(x)(~*as))):
  `(Atomy::Particle new(
      _undefined
      #~x
      ~(as collect [c]: wildcard(c))
    ))

macro(#(~r ~(x)(~*as))):
  `(Atomy::Particle new(
      ~(wildcard(r))
      #~x
      ~(as collect [c]: wildcard(c))
    ))

macro(#(~r [~*as])):
  `(Atomy::Particle new(
      ~(wildcard(r))
      #"[]"
      ~(as collect [c]: wildcard(c))
    ))

macro(#~(x: Binary)):
  `(Atomy::Particle new(
      ~(if(x private)
          then: '_undefined
          else: wildcard(x lhs))
      ~(x operator)
      [~(wildcard(x rhs))]
    ))

module(Atomy::Patterns):
  class(Particle < Pattern):
    initialize(@receiver, @message, @arguments) := #ok

    construct(g) := do:
      get(g)
      @receiver construct(g)
      g push-literal(@message)
      @arguments construct(g)
      g send(#new, 3)

    (== b) :=
      b kind-of?(Particle) &&
        @receiver == b receiver &&
        @message == b message &&
        @arguments == b arguments

    target(g) := do:
      g push-cpath-top
      g find-const(#Atomy)
      g find-const(#Particle)

    matches?(g) := do:
      mismatch = g new-label
      done = g new-label

      g dup
      target(g)
      g swap
      g kind-of
      g gif(mismatch)

      g dup
      g send(#message, 0)
      g push-literal(@message)
      g send(#"==", 1)
      g gif(mismatch)

      g dup
      g send(#receiver, 0)
      @receiver matches?(g)
      g gif(mismatch)

      g send(#arguments, 0)
      @arguments matches?(g)
      g dup
      g git(done)

      mismatch set!
      g pop
      g push-false

      done set!

    deconstruct(g, locals = ::Hash new) := do:
      g dup
      g send(#receiver, 0)
      @receiver deconstruct(g, locals)

      g send(#arguments, 0)
      @arguments deconstruct(g, locals)

`#(~r [~*as]) to-pattern :=
  Atomy::Patterns::Particle new $:
    r to-pattern
    #"[]"
    `[~*as] to-pattern

`#~(x: Atomy::AST::Binary) to-pattern :=
  Atomy::Patterns::Particle new $:
    if(x private)
      then: '_ to-pattern
      else: x lhs to-pattern
    x operator
    `[~(x rhs)] to-pattern

`#(~(x: Atomy::AST::Word)(~*as)) to-pattern :=
  Atomy::Patterns::Particle new $:
    '_ to-pattern
    x text
    `[~*as] to-pattern

`#(~r ~(x: Atomy::AST::Word)(~*as)) to-pattern :=
  Atomy::Patterns::Particle new $:
    r to-pattern
    x text
    `[~*as] to-pattern

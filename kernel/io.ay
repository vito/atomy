use("core")
use("define")
use("control-flow")

use("dynamic")

dynamic(output-port, $stdout)
dynamic(input-port, $stdin)
dynamic(error-port, $stderr)

x println := x tap: ^output-port puts(x to-s)
x dump := x tap: ^output-port print(x to-s)
x write := x tap: ^output-port puts(x show)

export

with-output-to((filename: String), mode = "w") &action :=
  let(output-port = File open(filename, mode)):
    action ensuring:
      ^output-port close

with-output-to(io) &action :=
  let(output-port = io):
    action call

with-error-to((filename: String), mode = "w") &action :=
  let(error-port = File open(filename, mode)):
    action ensuring:
      ^error-port close

with-error-to(io) &action :=
  let(error-port = io):
    action call


read-line(sep = $separator) := do:
  x = ^input-port gets(sep)

  unless(x):
    error(EndOfFile new(^input-port))

  x

read-lines(sep = $separator) := do:
  x = ^input-port readlines(sep)

  unless(x):
    error(EndOfFile new(^input-port))

  x

read-byte := do:
  x = ^input-port getc

  unless(x):
    error(EndOfFile new(^input-port))

  x

read-char := read-byte chr

read(length = nil, buffer = nil) :=
  ^input-port send(#read, length, buffer)

with-input-from((filename: String), mode = "r") &action :=
  let(input-port = File open(filename, mode)):
    action ensuring:
      ^input-port close

with-input-from(io) &action :=
  let(input-port = io):
    action call

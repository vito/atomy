namespace(atomy)

for-macro:
  define-class(nil, e: Atomy::AST::Constant) := `(class(~e) {})
  define-class(root, e: Atomy::AST::Constant) := `(class(~e < ~root) {})
  define-class(root, `(~n { ~*cs })) :=
    define-class(root, `(~(n)() { ~*cs }))
  define-class(root, x: `(~(name)(~*as))) :=
    define-class(root, `(~x {}))
  define-class(root, `(~(name)(~*as): ~*cs)) := do:
    attrs = []
    as each [a]:
      a through-quotes [x]:
        x match:
          `@~_ -> attrs << x

        x

    tmps = names(attrs size) collect [t]:
      Atomy::AST::Unquote new(0, t)

    pat = name
    attrs zip(tmps) [[a, t]]:
      pat =! `(~pat with(~a, ~t))

    cons = `(~(name)(~*tmps))

    pat-def =
      `(evaluate-when(compile, load, run):
          ~(Atomy::AST::QuasiQuote new(0, cons)) pattern :=
              ~(Atomy::AST::QuasiQuote new(0, pat)) pattern)

    class =
      if(root)
        then: `(~name < ~root)
        else: name

    `(export:
        class(~class):
          attr-accessor $:
            ~*(attrs collect [a]:
                `#~(a receiver))

          initialize(~*as) := nil

        ~pat-def

        ~*(cs collect [c]: define-class(name, c)))

macro('data ~(children: Block)):
  `(data(Object) ~children)

macro(data(root)):
  `(data(~root) {})

macro(data(root = 'Object) ~(children: Block)):
  `(do:
      ~(define-class(nil, `(~(root) ~children)))
      nil)

class(Atomy::AST::MacroQuote):
  export:
    quote(n, *_) := raise("unknown quoter: " + n inspect)

macro((x: Variable) ~(c: Atomy::AST::String)):
  MacroQuote new(
    line,
    x name,
    c raw || c value,
    @arguments collect(&#name)
    c value
  )

macro(macro-quoter(n) [*as] { *cs }):
  `(evaluate-when(compile, load, run):
      class(Atomy::AST::MacroQuote):
        export:
          define(quote(#~n, ~*as)):
            ~*cs)

for-macro:
  intp-segments(s) :=
    s split(Regexp new("(?<!\\\\)#\\{"), 2) match:
      [] -> ['""]

      [x] -> [x to-node]

      [pre, chunk] -> do:
        p = Atomy::Parser new(chunk)

        unless(p parse("interpolated")):
          p raise-error

        segments = [pre to-node, `(~(p result) to-s)]

        rest = p string [p pos .. -1]

        rest match:
          nil -> segments
          "" -> segments
          _ -> segments + intp-segments(rest)

  interpolated(x) :=
    Atomy::AST::Interpolation new(0, intp-segments(x))

  code-from("}" . rest, 0 = 0) := ["", rest join]
  code-from("}" . rest, depth = 0) := do:
    [c, r] = code-from(rest, depth - 1)
    ["{" + c, r]
  code-from("{" . rest, depth = 0) := do:
    [c, r] = code-from(rest, depth + 1)
    ["{" + c, r]
  code-from(x . rest, depth = 0) := do:
    [xs, r] = code-from(rest, depth + 1)
    [x + xs, r]

macro-quoter(w) [_, _, v]: v split

macro-quoter(r) [r, fs]:
  flags = 0

  when(fs include?("m")):
    flags |= Regexp::MULTILINE

  when(fs include?("i")):
    flags |= Regexp::IGNORECASE

  when(fs include?("x")):
    flags |= Regexp::EXTENDED

  when(fs include?("u")):
    flags |= Regexp::KCODE_UTF8

  `(::Regexp new(~interpolated(r), ~flags))

macro-quoter(raw) [r]: r

macro-quoter(i) [_, _, v]: interpolated(v)

macro(_undefined):
  Undefined new(line)

macro($(x: Primitive ? @value is-a?(::Integer) && @value > 0)):
  NthRef new(line, x value)

export:
  module(Atomy::AST):
    class(Undefined < Node):
      generate

      bytecode(g) := do:
        pos(g)
        g push-undef

      pattern := Atomy::Patterns::Any new

    class(NthRef < Rubinius::AST::NthRef):
      include(NodeLike)
      extend(SentientNode)
      attributes(#which)
      generate

    class(Interpolation < Node):
      children([#segments])
      generate

      bytecode(g) := do:
        pos(g)

        @segments each [s]:
          s compile(g)

        g string-build(@segments size)


for-macro:
  define-class(nil, e: Atomy::AST::Constant) := `(class(~e) {})
  define-class(root, e: Atomy::AST::Constant) := `(class(~e < ~root) {})
  define-class(root, `(~n { ~*cs })) :=
    define-class(root, `(~(n)() { ~*cs }))
  define-class(root, x: `(~(name)(~*as))) :=
    define-class(root, `(~x {}))
  define-class(root, `(~(name)(~*as): ~*cs)) := do:
    attrs = Array[]
    as each [a]:
      a through-quotes [x]:
        x match:
          `@~_ -> attrs << x

        x

    tmps = names(attrs size) collect [t]:
      Atomy::AST::Unquote new(0, t)

    pat = name
    attrs zip(tmps) [[a, t]]:
      pat =! `(~pat with(~a, ~t))

    cons = `(~(name)(~*tmps))

    pat-def =
      `(evaluate-when(compile, load, run):
          ~(Atomy::AST::QuasiQuote new(0, cons)) pattern :=
              ~(Atomy::AST::QuasiQuote new(0, pat)) pattern)

    class =
      if(root)
        then: `(~name < ~root)
        else: name

    `(do:
        class(~class):
          attr-accessor $:
            ~*(attrs collect [a]:
                `#~(a receiver))

          initialize(~*as) := nil

        ~pat-def

        ~*(cs collect [c]: define-class(name, c)))

macro(data ~(children: Block)):
  `(data(Object) ~children)

macro(data(~root)):
  `(data(~root) {})

macro(data(~(root = 'Object)) ~(children: Block)):
  `(do:
      ~(define-class(nil, `(~(root) ~children)))
      nil)

class(Atomy::AST::MacroQuote):
  quote(n, *_) := raise("unknown quoter: " + n inspect)

macro(~Word ~Atomy::AST::String):
  MacroQuote new(
    line,
    @left text,
    @right raw || @right value,
    []
    @right value
  )

macro(~Word ~(s: Atomy::AST::String)(~*args)):
  MacroQuote new(
    line,
    @left text,
    s raw || s value,
    args collect(&#text)
    s value
  )

macro(macro-quoter(~n) [~*as] { ~*cs }):
  `(evaluate-when(compile, load, run):
      class(Atomy::AST::MacroQuote):
        define(quote(#~n, ~*as)):
          ~*cs)

macro(~a .. ~b): `(Range new(~a, ~b))
macro(~a ... ~b): `(Range new(~a, ~b, true))

for-macro:
  intp-segments(s) :=
    s split(Regexp new("(?<!\\\\)#\\{"), 2) match:
      [] -> ['""]

      [x] -> [x to-node]

      [pre, chunk]:
        p = Atomy::Parser new(chunk)

        unless(p parse("interpolated")):
          p raise-error

        segments = [pre to-node, `(~(p result) to-s)]

        rest = p string [p pos .. -1]

        rest match:
          nil -> segments
          "" -> segments
          _ -> segments + intp-segments(rest)

  interpolated(x) :=
    Atomy::AST::Interpolation new(0, intp-segments(x))

  code-from("}" . rest, 0 = 0) := ["", rest join]
  code-from("}" . rest, depth = 0) := do:
    [c, r] = code-from(rest, depth - 1)
    ["{" + c, r]
  code-from("{" . rest, depth = 0) := do:
    [c, r] = code-from(rest, depth + 1)
    ["{" + c, r]
  code-from(x . rest, depth = 0) := do:
    [xs, r] = code-from(rest, depth + 1)
    [x + xs, r]

macro-quoter(w) [_, _, v]: v split

macro-quoter(r) [r, fs]:
  flags = 0

  when(fs include?("m")):
    flags |= Regexp::MULTILINE

  when(fs include?("i")):
    flags |= Regexp::IGNORECASE

  when(fs include?("x")):
    flags |= Regexp::EXTENDED

  when(fs include?("u")):
    flags |= Regexp::KCODE_UTF8

  `(::Regexp new(~interpolated(r), ~flags))

macro-quoter(raw) [r]: r

macro-quoter(i) [_, _, v]: interpolated(v)

macro(_undefined):
  Undefined new(line)

macro($~(x: Primitive ? @value is-a?(::Integer) && @value > 0)):
  NthRef new(line, x value)

module(Atomy::AST):
  class(Undefined < Node):
    generate

    bytecode(g) := do:
      pos(g)
      g push-undef

    pattern := Atomy::Patterns::Any new

  class(NthRef < Rubinius::AST::NthRef):
    include(NodeLike)
    extend(SentientNode)
    attributes(#which)
    generate

  class(Interpolation < Node):
    children([#segments])
    generate

    bytecode(g) := do:
      pos(g)

      @segments each [s]:
        s compile(g)

      g string-build(@segments size)


IO = use("io")

ConditionsSystem = self

-- registered handlers/restarts
dynamic(handlers, [])
dynamic(restarts, [])

for-macro:
  catcher(x) :=
    x match:
      Atomy::AST::Word ->
        #"restart:#{x text}"

      Atomy::AST::Compose ->
        #"restart:#{x left text}"

      Atomy::AST::Call ->
        #"restart:#{x name text}"

data(Restart(@name, @action))

Restart invoke(*args) :=
  throw(#"restart:#{name}", @action [*args])

data(Condition):
  Error(@backtrace):
    SimpleError(@value)
    ExceptionError(@exception)
    NoRestartError(@restart)
    PortError(@port):
      EndOfFile

  Warning(@backtrace):
    SimpleWarning(@value)

Condition name := class name

ExceptionError name := @exception class name

Condition message := inspect

SimpleError message := @value to-s
ExceptionError message := @exception message
SimpleWarning message := @value to-s
NoRestartError message := "unknown restart " + @restart show
EndOfFile message := "unexpected end-of-file for " + @port show


macro(~body bind { ~*handlers }):
  names [a]:
    callback = `([~a]: ~a match: ~*handlers)
    `(let(ConditionsSystem handlers = ~callback . ^(ConditionsSystem handlers)):
        ~body rescue:
          (e: StandardError) -> error(e))


macro(with-restarts(~*restarts) ~(block: Block)):
  pairs = pairs-from(restarts)

  rs = pairs collect [[n, e]]:
    n match:
      Word ->
        `(ConditionsSystem::Restart new(#~n, { ~e }))

      `(~(n)(~*as)) ->
        `(ConditionsSystem::Restart new(#~n, [~*as] { ~e }))

      `(~(n)(~*as) &~b) ->
        `(ConditionsSystem::Restart new(#~n, [~*as] &~b { ~e }))

  body =
    pairs reduce(
      `{ ~block rescue: (e: StandardError) -> error(e) }
    ) [x, [name, _]]:
      `{ catch(~catcher(name)) ~x }

  `(let(ConditionsSystem restarts = [~*rs] + ^(ConditionsSystem restarts)) ~body)


export

restart(name, *args) := do:
  ^restarts each [r]:
    when(r name == name):
      r invoke(*args)

  error(NoRestartError new(name))


signal(c) := do:
  hs = ^handlers dup

  until(hs empty?):
    callback = hs shift
    let(handlers = hs):
      callback [c]

  nil


error(x) := do:
  e =
    x match:
      Exception ->
        ExceptionError new(x) tap [err]:
          err backtrace = x locations

      Error ->
        x tap [err]:
          err backtrace = Rubinius::VM backtrace(0)

      _ ->
        SimpleError new(x) tap [err]:
          err backtrace = Rubinius::VM backtrace(0)

  signal(e)

  with-output-to(^(IO error-port)):
    ^debugger run(e)


warning(x) :=
  with-restarts(muffle-warning -> nil):
    w =
      x match:
        Warning ->
          x tap [wrn]:
            wrn backtrace = Rubinius::VM backtrace(0)

        _ ->
          SimpleWarning new(x) tap [wrn]:
            wrn backtrace = Rubinius::VM backtrace(0)

    signal(w)

    with-output-to(^(IO error-port)):
      (w name + ": " + w message) println

    nil


class(DefaultDebugger):
  class(<< self):
    define(show-error-banner(e)):
      ("-" * 78) println
      (e name + ": " + e message) each-line [l]:
        ("*** " + l) display

      "\n" display

    define(show-options-for(e)):
      when(^restarts empty?):
        exit(1)

      "\n" display
      "restarts:" println
      ^restarts each-with-index [r, i]:
        ("  :" + i to-s + " -> " + r name to-s) println

    define(run(e)):
      show-error-banner(e)

      show-options-for(e)

      "!> " display
      ^restarts [gets to-i] invoke

dynamic(debugger, DefaultDebugger)

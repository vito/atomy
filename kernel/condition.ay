namespace(atomy)

title"Condition System"

doc"
  Rather than traditional exceptions, Atomy sports a condition/restart \
  system modeled on Common Lisp's design. The native Ruby exception handling \
  is available, but conditions and restarts are much more flexible.
"

-- registered handlers/restarts
dynamic(handlers, [])
dynamic(restarts, [])

for-macro:
  catcher(x) :=
    Atomy::AST::Variable new(x line) $:
      x match:
        Atomy::AST::Variable ->
          "restart:" + x name

        Atomy::AST::Send ->
          "restart:" + x method-name

data(Restart(@name, @action))

Restart invoke(*args) :=
  throw(("restart:" + @name to-s) to-sym, @action [*args])

symbols(signal, warning, error, restart)

section("Conditions"):
  doc"
    Condition system hierarchy. You should subclass one of these to create \
    your own conditions.
  " for:
    data(Condition):
      Error(@backtrace):
        SimpleError(@value)
        ExceptionError(@exception)
        NoRestartError(@name)
        PortError(@port):
          EndOfFile

      Warning(@backtrace):
        SimpleWarning(@value)

  doc"
    Get the name of a condition. By default, this will be the class name, \
    but you may override this for your own behaviour.
  " for:
    Condition name := class name

    ExceptionError name := @exception class name

  doc"
    A human-friendly message displayed for the condition. Override this.
  " for:
    Condition message := inspect

    SimpleError message := @value to-s
    ExceptionError message := @exception message
    SimpleWarning message := @value to-s
    NoRestartError message := "unknown restart " + @name show
    EndOfFile message := "unexpected end-of-file for " + @port show


section("Handling"):
  doc"
    Invoke the \hl{name} restart, passing \hl{args} along to its callback.

    See \hl{with-restarts}.
  " spec {
    name is-a?(Symbol)
    => any
  } for {
    restart(name, *args) := do:
      ^restarts each [r]:
        when(r name == name):
          r invoke(*args)

      error(NoRestartError new(name))
  } examples:
    { with-restarts(foo -> 42):
        signal(#bar)
    } bind: #bar -> restart(#foo)


  doc"
    Register handlers for various signals for the duration of \hl{x}'s \
    execution.

    The body of \hl{y} is similar to \hl{match}; \hl{\italic{pattern} -> \
    \italic{body}}.

    The result is the result of \hl{body}.
  " spec {
    y contents all? [x]: x match { `(~_ -> ~_) -> true, _ -> false }
    => any
  } for {
    macro(body bind(&y)):
      names [a]:
        callback = `([~a]: ~a match: ~*(y contents))
        `(let(handlers = ^handlers + [~callback]):
            ~body rescue:
              (e: StandardError) -> error(e))
  } examples:
    { signal(#a) } bind: #a -> "got A!" print
    { signal(#b) } bind: #a -> "got A!" print
    { { signal(#a) } bind: #a -> "inner" print } bind: #a -> "outer" print


  doc"
    Register restarts available for the duration of \hl{body}'s execution.

    The \hl{restarts} should be in the form of \
    \hl{\italic{name}(*\italic{args}) -> \italic{body}}.

    The result is the result of \hl{body}.
  " spec {
    => any
  } for {
    macro(with-restarts(*restarts, &block)):
      rs = restarts collect [`(~n -> ~e)]:
        n match:
          Atomy::AST::Variable ->
            `(Restart new(#~n, { ~e }))

          Atomy::AST::Send -> do:
            name = Atomy::AST::Variable new(0, n method-name)
            `(Restart new(#~name, [~*(n arguments)] { ~e }))

      body =
        restarts reduce(
          `{ ~block rescue: (e: StandardError) -> error(e) }
        ) [x, `(~name -> ~_)]:
          `{ catch(#~catcher(name), &~x) }

      `(let(restarts = [~*rs] + ^restarts, &~body))
  } examples:
    { with-restarts(x -> 1, y -> 2):
        signal(#a)
    } bind: #a -> restart(#x)

    { with-restarts(x -> 1, y -> 2):
        signal(#a)
    } bind: #a -> restart(#y)

    { with-restarts(x(a) -> a * 7):
        signal(#a)
    } bind: #a -> restart(#x, 6)


section("Signalling"):
  doc"
    Signal a value through all bound handlers, nearest-first, stopping when \
    a restart is invoked.
  " spec {
    => nil
  } for {
    signal(c) := do:
      ^handlers reverse-each [callback]:
        callback [c]

      nil
  } examples:
    signal(#foo)
    { signal(#foo) } bind: #foo -> "got foo" print


  doc"
    Like \hl{signal}, except that if no restart is invoked, the current \
    \hl{^debugger} is started.

    If the given value is not an \hl{Error}, it is wrapped in a \
    \hl{SimpleError}. If the value is a Ruby \hl{Exception}, it is wrapped \
    in an \hl{ExceptionError}.
  " spec {
    => _
  } for {
    error(x) := do:
      e =
        x match:
          Exception ->
            ExceptionError new(x) tap [err]:
              err backtrace = x locations

          Error ->
            x tap [err]:
              err backtrace = Rubinius::VM backtrace(0)

          _ ->
            SimpleError new(x) tap [err]:
              err backtrace = Rubinius::VM backtrace(0)

      signal(e)

      with-output-to(^error-port):
        ^debugger run(e)
  } examples:
    error("Oh no!")
    { error("Oh no!") } bind: Error -> "INCOMING" print


  doc"
    Like \hl{signal}, except that if no restart is invoked, the warning is \
    printed to \hl{^error-port}.

    If the given value is not a \hl{Warning}, it is wrapped in a \
    \hl{SimpleWarning}. Warning messages can be muffled by binding for \
    \hl{Warning} and invoking the \hl{#muffle-warning} restart.
  " spec {
    => nil
  } for {
    warning(x) :=
      with-restarts(muffle-warning -> nil):
        w =
          x match:
            Warning ->
              x tap [wrn]:
                wrn backtrace = Rubinius::VM backtrace(0)

            _ ->
              SimpleWarning new(x) tap [wrn]:
                wrn backtrace = Rubinius::VM backtrace(0)

        signal(w)

        with-output-to(^error-port):
          (w name + ": " + w message) print

        nil
  } examples:
    warning("Suspicious!")
    { warning("Quiet, you!") } bind: Warning -> restart(#muffle-warning)


section("Debuggers"):
  doc"
    The default debugger. This will show the condition name, its message, \
    and let the user pick from the available restarts.
  " for:
    class(DefaultDebugger):
      class(<< self):
        define(show-error-banner(e)):
          ("-" * 78) print
          (e name + ": " + e message) each-line [l]:
            ("*** " + l) display

          "\n" display

        define(show-options-for(e)):
          when(^restarts empty?):
            exit(1)

          "\n" display
          "restarts:" print
          ^restarts each-with-index [r, i]:
            ("  :" + i to-s + " -> " + r name to-s) print

        define(run(e)):
          show-error-banner(e)

          show-options-for(e)

          "!> " display
          ^restarts [gets to-i] invoke

  doc"
    The current debugger. \hl{run} will be called with the condition as an \
    argument.
  " spec {
    respond-to?(#run)
  } for:
    dynamic(debugger, DefaultDebugger)

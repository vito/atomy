use("atomy")
IO = require("io")

dynamic(nesting-level, 0)
dynamic(stats)

class(Stats):
  attr-accessor(#passed, #failed)

  initialize := do:
    @passed = 0
    @failed = 0

  inspect := f"Stats(@passed = %d, @failed = %d)" [@passed, @failed]

indented(s) := " " * (^nesting-level * 2) + s

colored(color, s) := do:
  -- only makes sense to colorize if we're outputting to a terminal
  unless(^(IO output-port) tty?):
    return(s)

  codes =
    [ #black
      #red
      #green
      #yellow
      #blue
      #magenta
      #cyan
      #white
    ] to-a zip((0 .. 7) to-a)

  hash = Hash [codes]

  "\e[3" + hash [color] to-s + "m" + s + "\e[0m"


export

theorize &tests :=
  let(stats = Stats new):
    tests call
    "\n" display

    ^stats onto:
      f"total of %d tests (%s passed, %s failed)" [
        failed + passed
        colored(#green, passed to-s)
        if(failed == 0)
          then: "0"
          else: colored(#red, failed to-s)
      ] display

      "\n" display

    ^stats


describe(what) &body := do:
  indented(f"- %s" [what]) println

  let(nesting-level = ^nesting-level + 1):
    body call

  nil


it(description) &tests := do:
  { tests call
    indented(colored(#green, f"✓ %s" [description])) println
  } rescue {
    e:
      when(^stats):
        ^stats failed += 1

      indented(colored(#red, f"✗ %s" [description])) println
      indented(
        colored(
          #yellow
          f"  ` %s: %s" [
            e class name
            e message
          ]
        )
      ) println

      e backtrace first((ENV["THERIE_BT_LIMIT"] || 5) to-i) each [l]:
        indented(f"    %s" [colored(#cyan, l)]) println
  } else:
    when(^stats):
      ^stats passed += 1

  nil


macro(~x should ~(check: Block)):
  `(unless(~x onto ~check):
      raise(f"assertion failed for %v" ['~x pretty]))


x should-be(y) :=
  unless(x == y):
    raise(f"expected %v, got %v" [y, x])


x should-raise(y) :=
  x rescue {
    e ->
      unless(e kind-of?(y)):
        raise(f"expected exception %s, got: %s" [y, e class])
  } else:
      raise("#should-raise - no exception raised")


x should-error(y) :=
  { with-restarts(errored -> nil):
      x call
      raise("#should-error - no error signaled")
  } bind {
    (e: ExceptionError) ->
      raise(e exception)

    (e: Error):
      when(e kind-of?(y)):
        restart(#errored)

      raise(f"expected error %s, got: %s" [y, e message])
  }
